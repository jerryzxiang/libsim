%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{libsim}
\date{Dec 20, 2021}
\release{1.0}
\author{A.\@{} Caldwell, A.\@{} Preston, A.\@{} Valkonen, J.\@{} Xiang, J.\@{} Yanez}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{libsim} is a Python library that creates battery simulation models.

\sphinxAtStartPar
Check out the {\hyperref[\detokenize{usage::doc}]{\sphinxcrossref{\DUrole{doc}{Usage}}}} section for further information, including how to {\hyperref[\detokenize{usage:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{install}}}} the project.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This project is under active development.
\end{sphinxadmonition}


\chapter{Background}
\label{\detokenize{background:background}}\label{\detokenize{background::doc}}

\section{Models}
\label{\detokenize{background:models}}
\sphinxAtStartPar
One of the research challenges in the development of lithium\sphinxhyphen{}ion batteries
(LIBs) is to predict their behavior under different operating modes,
useful for estimating state of charge and state of health of batteries
in electric vehicles (EV’s). There exist empirical models, mostly equivalent
circuit\sphinxhyphen{}based, widely used in the Battery Management Systems (BMS) of
electronics and EV’s. These types of models use past experimental data of a
battery to anticipate its future states. Most of the experimental data used
to find charge/discharge characteristics rely on the current or cell
potential. On one hand, these empirical models are relatively fast and
simple computationally, but they have drawbacks. For example, the
physics\sphinxhyphen{}based parameters are not able to be predetermined. The battery
characteristics aren’t updated as the battery ages and a battery’s model
is unique to itself \sphinxhyphen{} it does not apply to all batteries but only a specific
type.

\sphinxAtStartPar
Other major types of models are Pseudo\sphinxhyphen{}two\sphinxhyphen{}Dimensional (P2D) and Single
Particle Model (SPM). Both popular battery models are widely used today.
The P2D model is commonly used in lithium\sphinxhyphen{}ion battery studies, and the
predicted behavior of this model matches experimental data quite accurately.
A significant drawback with this model is the difficulty to use in real\sphinxhyphen{}time
due to its computationally expensive nature. The SPM model simplifies
anode/cathode interactions and reduces the dimensionality down to one
dimension, which greatly enhances its computational capabilities. However,
it places greater importance on the parameters of the anodes and cathodes.


\chapter{Project Goals}
\label{\detokenize{project_goals:project-goals}}\label{\detokenize{project_goals::doc}}
\sphinxAtStartPar
This project focuses on estimating and predicting the state of charge (SOC)
and state of health (SOH) for lithium\sphinxhyphen{}ion batteries (LIBs) using a Single
Particle Model (SPM) in order to reduce the computational cost and allow
for the model to be implemented in real\sphinxhyphen{}time EV LIBs modeling. It accounts
for the impact of complex parameters such as ion diffusivity, ion particle
radius, and maximum ion concentration at the ion’s surface on the
performance of the battery.


\chapter{Design Process}
\label{\detokenize{design_process:design-process}}\label{\detokenize{design_process::doc}}
\sphinxAtStartPar
In this code suite, abstracting battery behavior was not a trivial task.
LIBs can be designed with many different types of anodes and cathodes
which directly affect the electro\sphinxhyphen{}chemical properties and electrolyte
interactions. To capture this variability, we decided to create a
dictionary of different lithium\sphinxhyphen{}ion battery types that each have
their own unique properties regarding diffusivity, particle radius,
and ion concentration. This increases the versatility of the code
suite to make the simulations widely applicable should an end user
decide to test through various types of lithium\sphinxhyphen{}ion batteries of
their choosing.

\sphinxAtStartPar
SPM model was used to simulate battery cycling behaviors. For
generating solutions a finite element method was chosen.
Architectural choices were made to allow for future
implementation of various different model types.


\section{UML DIAGRAM}
\label{\detokenize{design_process:uml-diagram}}
\sphinxAtStartPar
INCLUDE NEW UML DIAGRAM


\chapter{libsim}
\label{\detokenize{modules:libsim}}\label{\detokenize{modules::doc}}

\section{arguments module}
\label{\detokenize{arguments:arguments-module}}\label{\detokenize{arguments::doc}}

\section{batterycell module}
\label{\detokenize{batterycell:batterycell-module}}\label{\detokenize{batterycell::doc}}

\section{derivative module}
\label{\detokenize{derivative:module-derivative}}\label{\detokenize{derivative:derivative-module}}\label{\detokenize{derivative::doc}}\index{module@\spxentry{module}!derivative@\spxentry{derivative}}\index{derivative@\spxentry{derivative}!module@\spxentry{module}}
\sphinxAtStartPar
Derivative
\index{first\_derivative() (in module derivative)@\spxentry{first\_derivative()}\spxextra{in module derivative}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{derivative:derivative.first_derivative}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{derivative.}}\sphinxbfcode{\sphinxupquote{first\_derivative}}}{\emph{\DUrole{n}{Mesh}}, \emph{\DUrole{n}{coefficient}}, \emph{\DUrole{n}{timestep}}}{}
\sphinxAtStartPar
Calculates the first derivative in Fick’s Law

\end{fulllineitems}

\index{second\_derivative() (in module derivative)@\spxentry{second\_derivative()}\spxextra{in module derivative}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{derivative:derivative.second_derivative}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{derivative.}}\sphinxbfcode{\sphinxupquote{second\_derivative}}}{\emph{\DUrole{n}{Mesh}}, \emph{\DUrole{n}{coefficient}}, \emph{\DUrole{n}{timestep}}}{}
\sphinxAtStartPar
Calculates the second derivative in Fick’s Law
The coefficient to be passed is a function
Mesh is the mesh for which the derivative is to be evaluated.

\end{fulllineitems}



\section{electrode module}
\label{\detokenize{electrode:electrode-module}}\label{\detokenize{electrode::doc}}

\section{main module}
\label{\detokenize{main:main-module}}\label{\detokenize{main::doc}}

\section{mesh module}
\label{\detokenize{mesh:module-mesh}}\label{\detokenize{mesh:mesh-module}}\label{\detokenize{mesh::doc}}\index{module@\spxentry{module}!mesh@\spxentry{mesh}}\index{mesh@\spxentry{mesh}!module@\spxentry{module}}
\sphinxAtStartPar
Mesh
\index{Mesh1D (class in mesh)@\spxentry{Mesh1D}\spxextra{class in mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mesh.}}\sphinxbfcode{\sphinxupquote{Mesh1D}}}{\emph{\DUrole{n}{n\_timestep}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Mesh1D class
\index{add\_node() (mesh.Mesh1D method)@\spxentry{add\_node()}\spxextra{mesh.Mesh1D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Adds a node based on x location, returns new node

\end{fulllineitems}

\index{add\_nodes() (mesh.Mesh1D method)@\spxentry{add\_nodes()}\spxextra{mesh.Mesh1D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D.add_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodes}}}{\emph{\DUrole{n}{length}}, \emph{\DUrole{n}{n\_elements}}}{}
\sphinxAtStartPar
Add nodes of a length with n\_elements

\end{fulllineitems}


\end{fulllineitems}

\index{Mesh1D\_SPM (class in mesh)@\spxentry{Mesh1D\_SPM}\spxextra{class in mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mesh.}}\sphinxbfcode{\sphinxupquote{Mesh1D\_SPM}}}{\emph{\DUrole{n}{n\_timestep}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{mesh:mesh.Mesh1D}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{mesh.Mesh1D}}}}}

\sphinxAtStartPar
Mesh1D\_SPM class, subset of Mesh1D
\index{add\_node() (mesh.Mesh1D\_SPM method)@\spxentry{add\_node()}\spxextra{mesh.Mesh1D\_SPM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Adds a node based on x location, returns new node

\end{fulllineitems}

\index{add\_nodes() (mesh.Mesh1D\_SPM method)@\spxentry{add\_nodes()}\spxextra{mesh.Mesh1D\_SPM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM.add_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodes}}}{\emph{\DUrole{n}{length}}, \emph{\DUrole{n}{n\_elements}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Add nodes of a length with n\_elements

\end{fulllineitems}

\index{get\_concentration\_by\_id() (mesh.Mesh1D\_SPM method)@\spxentry{get\_concentration\_by\_id()}\spxextra{mesh.Mesh1D\_SPM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM.get_concentration_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_concentration\_by\_id}}}{\emph{\DUrole{n}{node\_id}}, \emph{\DUrole{n}{timestep}}}{}
\sphinxAtStartPar
Get concentration at a node, and return

\end{fulllineitems}


\end{fulllineitems}



\section{node module}
\label{\detokenize{node:module-node}}\label{\detokenize{node:node-module}}\label{\detokenize{node::doc}}\index{module@\spxentry{module}!node@\spxentry{node}}\index{node@\spxentry{node}!module@\spxentry{module}}
\sphinxAtStartPar
Node
\index{Node (class in node)@\spxentry{Node}\spxextra{class in node}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{node:node.Node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{node.}}\sphinxbfcode{\sphinxupquote{Node}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{node\_id}}, \emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Node class

\end{fulllineitems}

\index{Node\_SPM (class in node)@\spxentry{Node\_SPM}\spxextra{class in node}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{node:node.Node_SPM}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{node.}}\sphinxbfcode{\sphinxupquote{Node\_SPM}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{node\_id}}, \emph{\DUrole{n}{x}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{node:node.Node}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{node.Node}}}}}

\sphinxAtStartPar
Node\_SPM class, subset of Node

\end{fulllineitems}



\section{plot module}
\label{\detokenize{plot:plot-module}}\label{\detokenize{plot::doc}}

\section{solver module}
\label{\detokenize{solver:solver-module}}\label{\detokenize{solver::doc}}

\chapter{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}

\section{Installation}
\label{\detokenize{usage:installation}}\label{\detokenize{usage:id1}}
\sphinxAtStartPar
To use libsim, first install it using the following terminal command. This will
pull the newest version of the libsim library.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git clone https://github.com/jerryzxiang/libsim.git
\end{sphinxVerbatim}


\section{Modeling Batteries}
\label{\detokenize{usage:modeling-batteries}}
\sphinxAtStartPar
TO DO

\sphinxAtStartPar
This is where we describe how to model batteries. How we use the libsim package.


\chapter{Profiling}
\label{\detokenize{profiling:profiling}}\label{\detokenize{profiling::doc}}
\sphinxAtStartPar
TO DO


\chapter{Lessons Learned}
\label{\detokenize{lessons_learned:lessons-learned}}\label{\detokenize{lessons_learned::doc}}
\sphinxAtStartPar
Figure out good ways to verify tests when using a variety of parameters,
as most of our work is looking at experimental data which is difficult to source.

\sphinxAtStartPar
TO DO…


\chapter{Future Work}
\label{\detokenize{future:future-work}}\label{\detokenize{future::doc}}

\section{Graphic User Interface (GUI)}
\label{\detokenize{future:graphic-user-interface-gui}}
\sphinxAtStartPar
In order to simplify the utilization of libsim, we hope to integrate
a Graphic User Interface (GUI) to allow for an intuitive user
experience as opposed to terminal commands.


\section{Tests}
\label{\detokenize{future:tests}}
\sphinxAtStartPar
With the number of models implemented into libsim, the expected number
of edge cases and foreseeable issues will also grow. We hope to increase
the number of tests built into the code in order to reduce the possibility
for inaccuracies to be generated.


\section{Expanding Models Library}
\label{\detokenize{future:expanding-models-library}}
\sphinxAtStartPar
The final result of this project allowed for a computationally inexpensive
model of a reduced order that adapts well for real\sphinxhyphen{}time applications. In
future versions of libsim, we will look to implement PSeudo 2 Dimensional
(P2D) model aspects to improve accuracy while maintaining time cost in mind.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{derivative}\sphinxstyleindexpageref{derivative:\detokenize{module-derivative}}
\indexspace
\bigletter{m}
\item\relax\sphinxstyleindexentry{mesh}\sphinxstyleindexpageref{mesh:\detokenize{module-mesh}}
\indexspace
\bigletter{n}
\item\relax\sphinxstyleindexentry{node}\sphinxstyleindexpageref{node:\detokenize{module-node}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}