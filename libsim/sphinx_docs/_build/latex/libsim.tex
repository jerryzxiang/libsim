%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{libsim}
\date{Dec 20, 2021}
\release{1.0}
\author{A.\@{} Caldwell, A.\@{} Preston, A.\@{} Valkonen, J.\@{} Xiang, J.\@{} Yanez}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxAtStartPar
\sphinxstylestrong{libsim} is a Python library that creates battery simulation models.

\sphinxAtStartPar
Check out the {\hyperref[\detokenize{usage::doc}]{\sphinxcrossref{\DUrole{doc}{Usage}}}} section for further information, including how to {\hyperref[\detokenize{usage:installation}]{\sphinxcrossref{\DUrole{std,std-ref}{install}}}} the project.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
This project is under active development.
\end{sphinxadmonition}


\chapter{Background}
\label{\detokenize{background:background}}\label{\detokenize{background::doc}}

\section{Models}
\label{\detokenize{background:models}}
\sphinxAtStartPar
One of the research challenges in the development of lithium\sphinxhyphen{}ion batteries
(LIBs) is to predict their behavior under different operating modes, which
is useful for estimating state of charge and state of health of batteries
in electric vehicles (EVs). There exist empirical models, mostly equivalent
circuit\sphinxhyphen{}based, widely used in the Battery Management Systems (BMS) of
electronics and EVs. These types of models use past experimental data of a
battery to anticipate its future states. Most of the experimental data used
to find charge/discharge characteristics rely on the current or cell potential.
On one hand, these empirical models are relatively fast and simple computationally,
but they have drawbacks. For example, the physics\sphinxhyphen{}based parameters are not
able to be predetermined. The battery characteristics are not updated as the
battery ages and a battery’s model is unique to itself \sphinxhyphen{} it does not apply to
all batteries but only a specific type.

\sphinxAtStartPar
Electrochemical models are, on the other hand, more sophisticated. These
models are based on chemical/electrochemical kinetics and transport equations.
They may be used to simulate the LIB’s characteristics and reactions. Popular
electrochemical models are the Pseudo\sphinxhyphen{}two\sphinxhyphen{}Dimensional (P2D) Model and Single
Particle Model (SPM). The P2D model is commonly used in lithium\sphinxhyphen{}ion battery
studies, and the predicted behavior of this model matches experimental data q
uite accurately. A significant drawback with this model is the difficulty to
use in real\sphinxhyphen{}time due to its computationally expensive nature. The SPM model
simplifies anode/cathode interactions and reduces the dimensionality down to
one dimension, which greatly enhances its computational capabilities. However,
it places greater importance on the parameters of the anodes and cathodes.


\chapter{Project Goals}
\label{\detokenize{project_goals:project-goals}}\label{\detokenize{project_goals::doc}}
\sphinxAtStartPar
This project focuses on estimating and predicting the state of charge (SOC)
and state of health (SOH) for lithium\sphinxhyphen{}ion batteries (LIBs) using a Single
Particle Model (SPM) in order to reduce the computational cost and allow
for the model to be implemented in real\sphinxhyphen{}time EV LIBs modeling. It accounts
for the impact of complex parameters such as ion diffusivity, ion particle
radius, and maximum ion concentration at the ion’s surface on the
performance of the battery.

\sphinxAtStartPar
Modelling these parameters is useful to compare to experimental results.

\sphinxAtStartPar
Eventually, this project can be expanded to estimate and predict the state
of charge (SOC) and state of health (SOH) of LIBs, in order to reduce the
computational cost and allow for the model to be implemented in real\sphinxhyphen{}time
EV LIBs modeling.


\chapter{Design Process}
\label{\detokenize{design_process:design-process}}\label{\detokenize{design_process::doc}}
\sphinxAtStartPar
In this code suite, abstracting battery behavior was not a trivial task.
LIBs can be designed with many different types of anodes and cathodes
which directly affect the electro\sphinxhyphen{}chemical properties and electrolyte
interactions. To capture this variability, we decided to create a
dictionary of different lithium\sphinxhyphen{}ion battery types that each have
their own unique properties regarding diffusivity, particle radius,
and ion concentration. This increases the versatility of the code
suite to make the simulations widely applicable should an end user
decide to test through various types of lithium\sphinxhyphen{}ion batteries of
their choosing.

\sphinxAtStartPar
Finding a way to solve the first and second order derivatives of the
SPM model was also not as simple as just plugging values into an
equation. To remedy this, we decided to use a finite element method
that involves using a mesh that is composed of nodes, which was
necessary to analytically solve these governing equations.

\sphinxAtStartPar
The SPM model was used to simulate battery cycling behaviors. For
generating solutions a finite element method was chosen. Architectural
choices were made to allow for future implementation of various different
model types, though we had only implemented the finite element method.

\sphinxAtStartPar
Our initial design was less modularized than the final version, as many of
the tests we created to verify integration results relied on hard coded
constants and input parameters that could not be generalized at the conception.
Once testing was complete for one case of hard coded constants, we were able to
allow command line arguments to be passed into the program that allowed for
flexibility of the simulation. For another example, the electrode.py class was
very overloaded with a multitude of functions nested inside of it, but upon
further inspection these functions could easily exist in a separate file that
doesn’t need to be coupled with only the electrode class.


\section{UML DIAGRAM}
\label{\detokenize{design_process:uml-diagram}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[scale=0.5]{{UML_final}.png}
\caption{UML Diagram for libsim.}\label{\detokenize{design_process:id1}}\end{figure}


\chapter{libsim}
\label{\detokenize{modules:libsim}}\label{\detokenize{modules::doc}}

\section{arguments module}
\label{\detokenize{arguments:arguments-module}}\label{\detokenize{arguments::doc}}

\section{batterycell module}
\label{\detokenize{batterycell:module-batterycell}}\label{\detokenize{batterycell:batterycell-module}}\label{\detokenize{batterycell::doc}}\index{module@\spxentry{module}!batterycell@\spxentry{batterycell}}\index{batterycell@\spxentry{batterycell}!module@\spxentry{module}}
\sphinxAtStartPar
BatteryCell
\index{BatteryCell (class in batterycell)@\spxentry{BatteryCell}\spxextra{class in batterycell}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{batterycell:batterycell.BatteryCell}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{batterycell.}}\sphinxbfcode{\sphinxupquote{BatteryCell}}}{\emph{\DUrole{n}{capacity\_amp\_hour}}, \emph{\DUrole{n}{internal\_resistance}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
BatteryCell model class
Contains
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{capacity\_amp\_hour}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Amp Hour of the system.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{internal\_resistance}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Internal resistance of the battery.

\end{itemize}

\end{description}\end{quote}
\index{create\_anode() (batterycell.BatteryCell method)@\spxentry{create\_anode()}\spxextra{batterycell.BatteryCell method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{batterycell:batterycell.BatteryCell.create_anode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_anode}}}{\emph{\DUrole{n}{diffusivity}}, \emph{\DUrole{n}{particle\_radius}}, \emph{\DUrole{n}{max\_ion\_concentration}}}{}
\sphinxAtStartPar
Creates anode containing parameters from Electrode class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{diffusivity}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Diffusivity desired for the battery model. {[}(m\textasciicircum{}2)/s{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{particle\_radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Particle radius of the battery model particles. {[}m{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_ion\_concetration}} \textendash{} Maximum desired ion concentration. {[}mol/(m\textasciicircum{}3){]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_cathode() (batterycell.BatteryCell method)@\spxentry{create\_cathode()}\spxextra{batterycell.BatteryCell method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{batterycell:batterycell.BatteryCell.create_cathode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_cathode}}}{\emph{\DUrole{n}{diffusivity}}, \emph{\DUrole{n}{particle\_radius}}, \emph{\DUrole{n}{max\_ion\_concentration}}}{}
\sphinxAtStartPar
Creates cathode containing parameters from the Electrode Class.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{diffusivity}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Diffusivity desired for the battery model. {[}(m\textasciicircum{}2)/s{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{particle\_radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Particle radius of the battery model particles. {[}m{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{max\_ion\_concetration}} \textendash{} Maximum desired ion concentration. {[}mol/(m\textasciicircum{}3){]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_voltage() (batterycell.BatteryCell method)@\spxentry{get\_voltage()}\spxextra{batterycell.BatteryCell method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{batterycell:batterycell.BatteryCell.get_voltage}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_voltage}}}{\emph{\DUrole{n}{cathode\_potential}}, \emph{\DUrole{n}{anode\_potential}}, \emph{\DUrole{n}{INPUT\_CURRENT}}, \emph{\DUrole{n}{internal\_resistance}}}{}
\end{fulllineitems}


\end{fulllineitems}



\section{derivative module}
\label{\detokenize{derivative:module-derivative}}\label{\detokenize{derivative:derivative-module}}\label{\detokenize{derivative::doc}}\index{module@\spxentry{module}!derivative@\spxentry{derivative}}\index{derivative@\spxentry{derivative}!module@\spxentry{module}}
\sphinxAtStartPar
Derivative
\index{first\_derivative() (in module derivative)@\spxentry{first\_derivative()}\spxextra{in module derivative}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{derivative:derivative.first_derivative}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{derivative.}}\sphinxbfcode{\sphinxupquote{first\_derivative}}}{\emph{\DUrole{n}{Mesh}}, \emph{\DUrole{n}{coefficient}}, \emph{\DUrole{n}{timestep}}}{}
\sphinxAtStartPar
Calculates the first derivative in Fick’s Law using a “phantom node”.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Mesh}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Mesh for which the derivative is to be evaluated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coefficient}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Scalar coefficient for the derivative.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index for the timestep of the current derivative.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The first derivative of Fick’s Law for each of the nodes in the Mesh.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{second\_derivative() (in module derivative)@\spxentry{second\_derivative()}\spxextra{in module derivative}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{derivative:derivative.second_derivative}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{derivative.}}\sphinxbfcode{\sphinxupquote{second\_derivative}}}{\emph{\DUrole{n}{Mesh}}, \emph{\DUrole{n}{coefficient}}, \emph{\DUrole{n}{timestep}}}{}
\sphinxAtStartPar
Calculates the second derivative in Fick’s Law using a “phantom node”.
\begin{quote}
\begin{quote}\begin{description}
\item[{param Mesh}] \leavevmode
\sphinxAtStartPar
Mesh for which the derivative is to be evaluated.

\item[{type Mesh}] \leavevmode
\sphinxAtStartPar
{[}Mesh{]}

\item[{param coefficient}] \leavevmode
\sphinxAtStartPar
Scalar coefficient for the derivative.

\item[{type coefficient}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\item[{param timestep}] \leavevmode
\sphinxAtStartPar
Index for the timestep of the current derivative.

\item[{type timestep}] \leavevmode
\sphinxAtStartPar
{[}int{]}

\item[{return}] \leavevmode
\sphinxAtStartPar
The second derivative of Fick’s Law for each of the nodes in the Mesh.

\item[{rtype}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}



\section{electrode module}
\label{\detokenize{electrode:module-electrode}}\label{\detokenize{electrode:electrode-module}}\label{\detokenize{electrode::doc}}\index{module@\spxentry{module}!electrode@\spxentry{electrode}}\index{electrode@\spxentry{electrode}!module@\spxentry{module}}
\sphinxAtStartPar
Electrode
\index{Electrode (class in electrode)@\spxentry{Electrode}\spxextra{class in electrode}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{electrode.}}\sphinxbfcode{\sphinxupquote{Electrode}}}{\emph{\DUrole{n}{diffusivity}}, \emph{\DUrole{n}{particle\_radius}}, \emph{\DUrole{n}{max\_ion\_concentration}}, \emph{\DUrole{n}{charge}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Electrode class
Contains several variables:
diffusivity (m\textasciicircum{}2)/s{]},
particle\_radius {[}m{]},
max\_ion\_concentration {[}mol/(m\textasciicircum{}3){]},
charge {[}C{]}, 
number\_moles {[}mol{]}, 
volume {[}m\textasciicircum{}3{]}
\index{calculate\_effective\_area() (electrode.Electrode method)@\spxentry{calculate\_effective\_area()}\spxextra{electrode.Electrode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode.calculate_effective_area}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_effective\_area}}}{}{}
\sphinxAtStartPar
Calculates the effective area from the particle radius and 
particle number, which is calculated from the particle volume:
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
effective area from particle volume {[}m\textasciicircum{}3{]}

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_potential\_lookup\_tables() (electrode.Electrode method)@\spxentry{create\_potential\_lookup\_tables()}\spxextra{electrode.Electrode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode.create_potential_lookup_tables}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{create\_potential\_lookup\_tables}}}{\emph{\DUrole{n}{ref\_list}}}{}
\sphinxAtStartPar
Creates a potential lookup table based on a reference list.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ref\_list}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Reference list as base for potential lookup table.

\end{description}\end{quote}

\end{fulllineitems}

\index{electrode\_potential() (electrode.Electrode method)@\spxentry{electrode\_potential()}\spxextra{electrode.Electrode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode.electrode_potential}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{electrode\_potential}}}{\emph{\DUrole{n}{node\_container}}}{}
\sphinxAtStartPar
Returns potential of the electrode.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_container}} \textendash{} List of node objects.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
potential\_function

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{mesh\_initialize() (electrode.Electrode method)@\spxentry{mesh\_initialize()}\spxextra{electrode.Electrode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode.mesh_initialize}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_initialize}}}{\emph{\DUrole{n}{length}}, \emph{\DUrole{n}{n\_elements}}, \emph{\DUrole{n}{n\_timestep}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Initializes the mesh for numerical calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{length}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Length of the line segment on which the mesh is generated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_elements}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Number of elements that the length will be split into.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_timestep}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Number of timesteps to be analyzed.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_concentration}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Initial concentration of nodes.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_input\_current() (electrode.Electrode method)@\spxentry{set\_input\_current()}\spxextra{electrode.Electrode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode.set_input_current}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_input\_current}}}{\emph{\DUrole{n}{input\_current}}}{}
\sphinxAtStartPar
Sets input current
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{input\_current}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Input Current set for the electrode. {[}A{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{simulation\_step() (electrode.Electrode method)@\spxentry{simulation\_step()}\spxextra{electrode.Electrode method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{electrode:electrode.Electrode.simulation_step}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{simulation\_step}}}{\emph{\DUrole{n}{timestep\_id}}, \emph{\DUrole{n}{dt}}}{}
\sphinxAtStartPar
Simulates a step.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index for the timestep of the current derivative.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{main module}
\label{\detokenize{main:main-module}}\label{\detokenize{main::doc}}

\section{mesh module}
\label{\detokenize{mesh:module-mesh}}\label{\detokenize{mesh:mesh-module}}\label{\detokenize{mesh::doc}}\index{module@\spxentry{module}!mesh@\spxentry{mesh}}\index{mesh@\spxentry{mesh}!module@\spxentry{module}}
\sphinxAtStartPar
Mesh

\sphinxAtStartPar
Parent class for classes that describe the computational mesh for each
different type of model/problem.
\index{Mesh1D (class in mesh)@\spxentry{Mesh1D}\spxextra{class in mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mesh.}}\sphinxbfcode{\sphinxupquote{Mesh1D}}}{\emph{\DUrole{n}{n\_timestep}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Mesh 1D is a 1\sphinxhyphen{}dimensional mesh composed of Nodes complete with
functions to create Nodes. It includes an indexing system in order
to be able to access individual nodes as needed (post\sphinxhyphen{}processing).

\sphinxAtStartPar
In order to initialize a Mesh1D, a variable n\_timestep is needed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_timestep}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Number of timesteps to be taken.

\end{description}\end{quote}
\index{add\_node() (mesh.Mesh1D method)@\spxentry{add\_node()}\spxextra{mesh.Mesh1D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Adds a node based on x location, and returns a new node.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index identifier for location of the node.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
x

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{[}int{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_nodes() (mesh.Mesh1D method)@\spxentry{add\_nodes()}\spxextra{mesh.Mesh1D method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D.add_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodes}}}{\emph{\DUrole{n}{length}}, \emph{\DUrole{n}{n\_elements}}}{}
\sphinxAtStartPar
Add nodes of a specified length with n\_elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{length}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Length of nodes to add.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_elements}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Number of nodes to add.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Mesh1D\_SPM (class in mesh)@\spxentry{Mesh1D\_SPM}\spxextra{class in mesh}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{mesh.}}\sphinxbfcode{\sphinxupquote{Mesh1D\_SPM}}}{\emph{\DUrole{n}{n\_timestep}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{mesh:mesh.Mesh1D}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{mesh.Mesh1D}}}}}

\sphinxAtStartPar
Mesh1D\_SPM class inherits Mesh1D. Here the one dimensional Mesh
is implemented for the use with SPM model.
\index{add\_node() (mesh.Mesh1D\_SPM method)@\spxentry{add\_node()}\spxextra{mesh.Mesh1D\_SPM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM.add_node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_node}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Adds a node based on x location.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index identifier for location of the node.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_concentration}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Initial concentration of ions at each node. {[}mol/(m\textasciicircum{}3){]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_nodes() (mesh.Mesh1D\_SPM method)@\spxentry{add\_nodes()}\spxextra{mesh.Mesh1D\_SPM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM.add_nodes}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_nodes}}}{\emph{\DUrole{n}{length}}, \emph{\DUrole{n}{n\_elements}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Add nodes of a length with n\_elements
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{length}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Length of nodes to add.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{n\_elements}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Number of nodes to add.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initial\_concentration}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Initial concentration of ions at each node. {[}mol/(m\textasciicircum{}3){]}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_concentration\_by\_id() (mesh.Mesh1D\_SPM method)@\spxentry{get\_concentration\_by\_id()}\spxextra{mesh.Mesh1D\_SPM method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{mesh:mesh.Mesh1D_SPM.get_concentration_by_id}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_concentration\_by\_id}}}{\emph{\DUrole{n}{node\_id}}, \emph{\DUrole{n}{timestep}}}{}
\sphinxAtStartPar
Get concentration at a node, and return

\sphinxAtStartPar
Add nodes of a specified length with n\_elements.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Unique identifier for a node.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Current timestep.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
Node concentration

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\section{node module}
\label{\detokenize{node:module-node}}\label{\detokenize{node:node-module}}\label{\detokenize{node::doc}}\index{module@\spxentry{module}!node@\spxentry{node}}\index{node@\spxentry{node}!module@\spxentry{module}}
\sphinxAtStartPar
Node

\sphinxAtStartPar
Node is a parent class for classes that describe the points in the mesh
for each type of problem. A Node is a general representation of a point 
in space. This parent class does not define the dimensionality or any 
other attributes.
\index{Node (class in node)@\spxentry{Node}\spxextra{class in node}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{node:node.Node}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{node.}}\sphinxbfcode{\sphinxupquote{Node}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{node\_id}}, \emph{\DUrole{n}{x}}}{}
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Node class
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{mesh}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Mesh}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Mesh

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Unique identifier for a node.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index identifier for location of the node.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{Node\_SPM (class in node)@\spxentry{Node\_SPM}\spxextra{class in node}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{node:node.Node_SPM}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{node.}}\sphinxbfcode{\sphinxupquote{Node\_SPM}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{node\_id}}, \emph{\DUrole{n}{x}}, \emph{\DUrole{n}{initial\_concentration}}}{}
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{node:node.Node}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{node.Node}}}}}

\sphinxAtStartPar
Node\_SPM class, subset of Node

\sphinxAtStartPar
Inherits Node. This is the implementation of Node for SPM
modeling.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{Mesh}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Mesh

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{node\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Unique identifier for a node.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Index Identifier for location of the node.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\section{plot module}
\label{\detokenize{plot:module-plot}}\label{\detokenize{plot:plot-module}}\label{\detokenize{plot::doc}}\index{module@\spxentry{module}!plot@\spxentry{plot}}\index{plot@\spxentry{plot}!module@\spxentry{module}}
\sphinxAtStartPar
module to plot battery parameters over time
\index{plot\_concentration() (in module plot)@\spxentry{plot\_concentration()}\spxextra{in module plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:plot.plot_concentration}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot.}}\sphinxbfcode{\sphinxupquote{plot\_concentration}}}{\emph{\DUrole{n}{electrode}}, \emph{\DUrole{n}{potential}}, \emph{\DUrole{n}{electrode\_type}}}{}
\end{fulllineitems}

\index{plot\_voltage() (in module plot)@\spxentry{plot\_voltage()}\spxextra{in module plot}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{plot:plot.plot_voltage}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{plot.}}\sphinxbfcode{\sphinxupquote{plot\_voltage}}}{\emph{\DUrole{n}{time}}, \emph{\DUrole{n}{voltage}}, \emph{\DUrole{n}{title}}}{}
\end{fulllineitems}



\section{solver module}
\label{\detokenize{solver:module-solver}}\label{\detokenize{solver:solver-module}}\label{\detokenize{solver::doc}}\index{module@\spxentry{module}!solver@\spxentry{solver}}\index{solver@\spxentry{solver}!module@\spxentry{module}}
\sphinxAtStartPar
Solver \sphinxhyphen{} simulation stepper
\index{apply\_dirichlet\_bc() (in module solver)@\spxentry{apply\_dirichlet\_bc()}\spxextra{in module solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.apply_dirichlet_bc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{solver.}}\sphinxbfcode{\sphinxupquote{apply\_dirichlet\_bc}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{timestep\_id}}, \emph{\DUrole{n}{surface\_c}}}{}
\sphinxAtStartPar
Applies Dirichlet boundary conditions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{mesh}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} mesh to which conditions will be applied to.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} index for the timestep.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{surface\_c}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} concentration of the surface

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{apply\_neumann\_bc() (in module solver)@\spxentry{apply\_neumann\_bc()}\spxextra{in module solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.apply_neumann_bc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{solver.}}\sphinxbfcode{\sphinxupquote{apply\_neumann\_bc}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{timestep\_id}}}{}
\sphinxAtStartPar
Applies Neumann boundary conditions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{mesh}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} mesh to which conditions will be applied to.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} index for the timestep.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_surface\_concentration() (in module solver)@\spxentry{calculate\_surface\_concentration()}\spxextra{in module solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.calculate_surface_concentration}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{solver.}}\sphinxbfcode{\sphinxupquote{calculate\_surface\_concentration}}}{\emph{\DUrole{n}{electrode}}, \emph{\DUrole{n}{timestep\_id}}}{}
\sphinxAtStartPar
Calculates surface concentration
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{electrode}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{electrode}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} electrode instance for which surface concentration will be calculated.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} index for the timestep.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
The surface concentration.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{[}double{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{euler\_step() (in module solver)@\spxentry{euler\_step()}\spxextra{in module solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.euler_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{solver.}}\sphinxbfcode{\sphinxupquote{euler\_step}}}{\emph{\DUrole{n}{electrode}}, \emph{\DUrole{n}{timestep\_id}}, \emph{\DUrole{n}{dt}}}{}
\sphinxAtStartPar
Euler stepper
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{electrode}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{electrode}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} electrode instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} index for the timestep.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} length of the timestep

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{simulation\_step() (in module solver)@\spxentry{simulation\_step()}\spxextra{in module solver}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{solver:solver.simulation_step}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{solver.}}\sphinxbfcode{\sphinxupquote{simulation\_step}}}{\emph{\DUrole{n}{electrode}}, \emph{\DUrole{n}{timestep\_id}}, \emph{\DUrole{n}{dt}}}{}
\sphinxAtStartPar
Advances the simulation one step
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{electrode}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{electrode}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} electrode instance

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{timestep\_id}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} index for the timestep.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dt}} (\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{double}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} length of the timestep

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Usage}
\label{\detokenize{usage:usage}}\label{\detokenize{usage::doc}}

\section{Installation}
\label{\detokenize{usage:installation}}\label{\detokenize{usage:id1}}
\sphinxAtStartPar
The third\sphinxhyphen{}party packages required are: \sphinxtitleref{python3}, \sphinxtitleref{numpy}, \sphinxtitleref{scipy.interpolate},
\sphinxtitleref{math}, and \sphinxtitleref{matplotlib}. These packages can all be installed via \sphinxtitleref{pip3}.

\sphinxAtStartPar
The repo can be cloned from \sphinxtitleref{https://github.com/jerryzxiang/libsim.git} or
installed via

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textasciigrave{}
pip3 install git+ssh://git@github.com:jerryzxiang/libsim.git
\textasciigrave{}}}


\section{Modeling Batteries}
\label{\detokenize{usage:modeling-batteries}}
\sphinxAtStartPar
This program is run through the driver code file, \sphinxtitleref{main.py}, which takes 8
command line arguments. As of now, there is no GUI. The inputs are the cathode,
anode, input current, capacity of the cell in amp hours, the number of radial
segments, the simulation time in seconds, and the time steps. An example is
shown here for an LIB with an LFP cathode and graphite anode:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textasciigrave{}
\$ python3 main.py LFP graphite 0.5 2.3 1.5 10 10 0.001
\textasciigrave{}}}

\sphinxAtStartPar
To get help, use \sphinxtitleref{python3 main.py \sphinxhyphen{}h’}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZdl{} }git clone https://github.com/jerryzxiang/libsim.git
\end{sphinxVerbatim}


\chapter{Profiling and Tuning Results}
\label{\detokenize{profiling:profiling-and-tuning-results}}\label{\detokenize{profiling::doc}}
\sphinxAtStartPar
We ran an initial profiling assessment using cProfile on the alpha version of libsim.
By far the slowest function in terms of runtime was simulation\_step within the electrode
class. From that analysis, it became clear that the function was a bit overloaded with
tasks. We then refactored the stepper code into a new separate solver file to reduce
some of this complexity. As a result, the runtime of this electrode code was reduced
by around 90\%, from 1.5 seconds to 0.15 seconds.

\sphinxAtStartPar
At this point, the longest running portion of the code is that associated with the
creation and plotting of the output graphs. These functions are integral to the
usage of the library, and are executed in an efficient manner as of now utilizing pyplot.


\chapter{Lessons Learned}
\label{\detokenize{lessons_learned:lessons-learned}}\label{\detokenize{lessons_learned::doc}}
\sphinxAtStartPar
Figured out good ways to verify tests when using a variety of parameters,
as most of our work is looking at experimental data which is difficult
to source.

\sphinxAtStartPar
Pair programming was very useful for catching bugs early on.

\sphinxAtStartPar
Commit often, establish workflow early


\chapter{Future Work}
\label{\detokenize{future:future-work}}\label{\detokenize{future::doc}}

\section{Graphic User Interface (GUI)}
\label{\detokenize{future:graphic-user-interface-gui}}
\sphinxAtStartPar
In order to simplify the utilization of libsim, we hope to integrate
a Graphic User Interface (GUI) to allow for an intuitive user
experience as opposed to terminal commands.


\section{Tests}
\label{\detokenize{future:tests}}
\sphinxAtStartPar
With the number of models implemented into libsim, the expected number
of edge cases and foreseeable issues will also grow. We hope to increase
the number of tests built into the code in order to reduce the possibility
for inaccuracies to be generated.


\section{Expanding Models Library}
\label{\detokenize{future:expanding-models-library}}
\sphinxAtStartPar
The final result of this project allowed for a computationally inexpensive
model of a reduced order that adapts well for real\sphinxhyphen{}time applications. In
future versions of libsim, we will look to implement PSeudo 2 Dimensional
(P2D) model aspects to improve accuracy while maintaining time cost in mind.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{batterycell}\sphinxstyleindexpageref{batterycell:\detokenize{module-batterycell}}
\indexspace
\bigletter{d}
\item\relax\sphinxstyleindexentry{derivative}\sphinxstyleindexpageref{derivative:\detokenize{module-derivative}}
\indexspace
\bigletter{e}
\item\relax\sphinxstyleindexentry{electrode}\sphinxstyleindexpageref{electrode:\detokenize{module-electrode}}
\indexspace
\bigletter{m}
\item\relax\sphinxstyleindexentry{mesh}\sphinxstyleindexpageref{mesh:\detokenize{module-mesh}}
\indexspace
\bigletter{n}
\item\relax\sphinxstyleindexentry{node}\sphinxstyleindexpageref{node:\detokenize{module-node}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{plot}\sphinxstyleindexpageref{plot:\detokenize{module-plot}}
\indexspace
\bigletter{s}
\item\relax\sphinxstyleindexentry{solver}\sphinxstyleindexpageref{solver:\detokenize{module-solver}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}